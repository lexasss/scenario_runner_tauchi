from enum import IntEnum, IntFlag
from typing import Callable, Optional, List, Set, Any, Tuple, Union, Iterator

import carla_command

class Actor:
    attributes: dict[str,Any]
    id: int
    is_alive: bool
    parent: Actor
    semantic_tags: List[int]
    type_id: str
    def add_angular_impulse(self, angular_impulse: Vector3D) -> None: ...
    def add_force(self, force: Vector3D) -> None: ...
    def add_impulse(self, impulse: Vector3D) -> None: ...
    def add_torque(self, torque: Vector3D) -> None: ...
    def close_door(self, door_idx: VehicleDoor) -> None: ...
    def destroy(self) -> bool: ...
    def enable_chrono_physics(self,
                              max_substeps: int,
                              max_substep_delta_time: int,
                              vehicle_json: str,
                              powertrain_json: str,
                              tire_json: str,
                              base_json_path: str) -> None: ...
    def enable_constant_velocity(self, velocity: Vector3D) -> None: ...
    def open_door(self, door_idx: VehicleDoor) -> None: ...
    def show_debug_telemetry(self, enabled: bool = True) -> None: ...
    def get_acceleration(self) -> Vector3D: ...
    def get_angular_velocity(self) -> Vector3D: ...
    def get_location(self) -> Location: ...
    def get_transform(self) -> Transform: ...
    def get_velocity(self) -> Vector3D: ...
    def get_world(self) -> World: ...
    def set_enable_gravity(self, enabled: bool) -> None: ...
    def set_location(self, location: Location) -> None: ...
    def set_simulate_physics(self, enabled: bool = True) -> None: ...
    def set_target_angular_velocity(self, angular_velocity: Vector3D) -> None: ...
    def set_target_velocity(self, velocity: Vector3D) -> None: ...
    def set_transform(self, transform: Transform) -> None: ...
    def __str__(self) -> str: ...
class ActorAttribute:
    id: str
    is_modifiable: bool
    recommended_values: List[str]
    type: ActorAttributeType
    def as_bool(self) -> bool: ...
    def as_color(self) -> Color: ...
    def as_float(self) -> float: ...
    def as_int(self) -> int: ...
    def as_str(self) -> str: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: Union[bool, int, float, str, Color, ActorAttribute]) -> bool: ...
    def __float__(self) -> float: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: Union[bool, int, float, str, Color, ActorAttribute]) -> bool: ...
    def __nonzero__(self) -> bool: ...
    def __str__(self) -> str: ...
class ActorAttributeType(IntEnum):
    Bool: int
    Int: int
    Float: int
    String: int
    RGBColor: int
class ActorBlueprint:
    id: str
    tags: List[str]
    def has_attribute(self, id: str) -> bool: ...
    def has_tag(self, tag: str) -> bool: ...
    def match_tags(self, wildcard_pattern: str) -> bool: ...
    def get_attribute(self, key: str) -> ActorAttribute: ...
    def set_attribute(self, key: str, value: str) -> None: ...
    def __iter__(self) -> Iterator[ActorAttribute]: ...
    def __len__(self) -> int: ...
    def __str__(self) -> str: ...
class ActorList:
    def filter(self, wildcard_pattern: str) -> list[Actor]: ...
    def find(self, actor_id: int) -> Actor: ...
    def __getitem__(self, pos: int) -> Actor: ...
    def __iter__(self) -> Iterator[Actor]: ...
    def __len__(self) -> int: ...
    def __str__(self) -> str: ...
class ActorSnapshot:
    id: int
    def get_acceleration(self) -> Vector3D: ...
    def get_angular_velocity(self) -> Vector3D: ...
    def get_transform(self) -> Transform: ...
    def get_velocity(self) -> Vector3D: ...
class AttachmentType(IntEnum):
    Rigid: int
    SpringArm: int
class BlueprintLibrary:
    def filter(self, wildcard_pattern: str) -> BlueprintLibrary: ...
    def find(self, id: str) -> Optional[ActorBlueprint]: ...
    def __getitem__(self, pos: int) -> ActorBlueprint: ...
    def __iter__(self) -> Iterator[ActorBlueprint]: ...
    def __len__(self) -> int: ...
    def __str__(self) -> str: ...
class BoundingBox:
    extent: Vector3D
    location: Location
    rotation: Rotation
    def __init__(self, location: Location, extent: Vector3D) -> None: ...
    def contains(self, world_point: Location, transform: Transform) -> bool: ...
    def get_local_vertices(self) -> Location: ...
    def get_world_vertices(self, transform: Transform) -> List[Location]: ...
    def __eq__(self, other: BoundingBox) -> bool: ...
    def __ne__(self, other: BoundingBox) -> bool: ...
    def __str__(self) -> str: ...
class CityObjectLabel(IntEnum):
    NONE: int
    Buildings: int
    Fences: int
    Other: int
    Pedestrians: int
    Poles: int
    RoadLines: int
    Roads: int
    Sidewalks: int
    TrafficSigns: in(Actor)t
    Vegetation: int
    Vehicles: int
    Walls: int
    Sky: int
    Ground: int
    Bridge: int
    RailTrack: int
    GuardRail: int
    TrafficLight: int
    Static: int
    Dynamic: int
    Water: int
    Terrain: int
    Any: int
class Client:
    def __init__(self, host: str = '127.0.0.1', port: int = 2000, worker_threads: int = 0) -> None: ...
    def apply_batch(self, commands: List[str]) -> None: ...
    def apply_batch_sync(self, commands: List[str], due_tick_cue: bool = False) -> List[carla_command.Response]: ...
    def generate_opendrive_world(self,
                                 opendrive: str,
                                 parameters: OpendriveGenerationParameters = ..., # 2.0, 50.0, 1.0, 0.6, True, True)
                                 reset_settings: bool = True) -> None: ...
    def load_world(self,
                   map_name: str,
                   reset_settings: bool = True,
                   map_layers: MapLayer = MapLayer.All) -> World: ...
    def reload_world(self, reset_settings: bool = True) -> None: ...
    def replay_file(self,
                    name: str,
                    start: float,
                    duration: float,
                    follow_id: int,
                    replay_sensors: bool) -> None: ...
    def request_file(self, name: str) -> None: ...
    def show_recorder_actors_blocked(self,
                                     filename: str,
                                     min_time: float,
                                     min_distance: float) -> str: ...
    def show_recorder_collisions(self,
                                 filename: str,
                                 category1: str,
                                 category2: str) -> str: ...
    def show_recorder_file_info(self,
                                filename: str,
                                show_all: bool) -> str: ...
    def start_recorder(self,
                       filename: str,
                       additional_data: bool = False) -> None: ...
    def stop_recorder(self) -> None: ...
    def stop_replayer(self, keep_actors: bool) -> None: ...
    def get_available_maps(self) -> List[str]: ...
    def get_client_version(self) -> str: ...
    def get_required_files(self,
                           folder: str,
                           download: bool = True) -> None: ...
    def get_server_version(self) -> str: ...
    def get_trafficmanager(self, client_connection: int = 8000) -> TrafficManager: ...
    def get_world(self) -> World: ...
    def set_files_base_folder(self, path: str) -> None: ...
    def set_replayer_ignore_hero(self, ignore_hero: bool) -> None: ...
    def set_replayer_time_factor(self, time_factor: float = 1.0) -> None: ...
    def set_timeout(self, seconds: float) -> None: ...
class Color:
    r: int
    g: int
    b: int
    a: int
    def __init__(self, r: int = 0, g: int = 0, b: int = 0, a: int = 255) -> None: ...
    def __eq__(self, other: Color) -> bool: ...
    def __ne__(self, other: Color) -> bool: ...
    def __str__(self) -> str: ...
class ColorConverter(IntEnum):
    CityScapesPalette: int
    Depth: int
    LogarithmicDepth: int
    Raw: int
class DebugHelper:
    def draw_arrow(self,
                   begin: Location,
                   end: Location,
                   thickness: float = 0.1,
                   arrow_size: float = 0.1,
                   color: Color = Color(255,0,0),
                   life_time: float = -1.0) -> None: ...
    def draw_box(self,
                 box: BoundingBox,
                 rotation: Rotation,
                 thickness: float = 0.1,
                 color: Color = Color(255,0,0),
                 life_time: float = -1.0) -> None: ...
    def draw_line(self,
                  begin: Location,
                  end: Location,
                  thickness: float = 0.1,
                  color: Color = Color(255,0,0),
                  life_time: float = -1.0) -> None: ...
    def draw_point(self,
                   location: Location,
                   size: float = 0.1,
                   color: Color = Color(255,0,0),
                   life_time: float = -1.0) -> None: ...
    def draw_string(self,
                    location: Location,
                    text: str,
                    draw_shadow : bool = False,
                    color: Color = Color(255,0,0),
                    life_time: float = -1.0) -> None: ...
class EnvironmentObject:
    transform: Transform
    bounding_box: BoundingBox
    id: int
    name: str
    type: CityObjectLabel
    def __str__(self) -> str: ...
class FloatColor:
    r: float
    g: float
    b: float
    a: float
    def __init__(self, r: float = 0, g: float = 0, b: float = 0, a: float = 1.0) -> None: ...
    def __eq__(self, other: FloatColor) -> bool: ...
    def __ne__(self, other: FloatColor) -> bool: ...
    def __str__(self) -> str: ...
class GearPhysicsControl:
    ratio: float
    down_ratio: float
    up_ratio: float
    def __init__(self,
                 ratio: float = 1.0,
                 down_ratio: float = 0.5,
                 up_ratio: float = 0.65) -> None: ...
    def __eq__(self, other: GearPhysicsControl) -> bool: ...
    def __ne__(self, other: GearPhysicsControl) -> bool: ...
    def __str__(self) -> str: ...
class GeoLocation:
    latitude: float
    longitude: float
    altitude: float
    def __init__(self,
                 latitude: float = 0.0,
                 longitude: float = 0.0,
                 altitude: float = 0.0) -> None: ...
    def __eq__(self, other: GeoLocation) -> bool: ...
    def __ne__(self, other: GeoLocation) -> bool: ...
    def __str__(self) -> str: ...
class Image(SensorData):
    fov: float
    height: int
    width: int
    raw_data: bytes
    def convert(self, color_converter: ColorConverter) -> None: ...
    def save_to_disk(self, path: str, color_converter: ColorConverter = ColorConverter.Raw) -> None: ...
    def __getitem__(self, pos: int) -> Color: ...
    def __iter__(self) -> Iterator[Color]: ...
    def __len__(self) -> int: ...
    def __setitem__(self, pos: int, color: Color) -> None: ...
    def __str__(self) -> str: ...
class Junction:
    id: int
    bounding_box: BoundingBox
    def get_waypoints(self, lane_type: LaneType) -> List[Tuple[Waypoint]]: ...
class LabelledPoint:
    location: Location
    label: str
class Landmark:
    road_id: int
    distance: float
    s: float
    t: float
    id: str
    name: str
    is_dynamic: bool
    orientation: LandmarkOrientation
    z_offset: float
    country: str
    type: str
    sub_type: str
    value: float
    unit: str
    height: float
    width: float
    text: str
    h_offset: float
    pitch: float
    roll: float
    waypoint: Waypoint
    transform: Transform
    def get_lane_validities(self) -> List[Tuple[int]]: ...
class LandmarkOrientation(IntEnum):
    Positive: int
    Negative: int
    Both: int
class LaneChange(IntEnum):
    NONE: int
    Right: int
    Left: int
    Both: int
class LaneMarking:
    color: LaneMarkingColor
    lane_change: LaneChange
    type: LaneMarkingType
    width: float
class LaneMarkingColor(IntEnum):
    Standard: int
    Blue: int
    Green: int
    Red: int
    White: int
    Yellow: int
    Other: int
class LaneMarkingType(IntEnum):
    NONE: int
    Other: int
    Broken: int
    Solid: int
    SolidSolid: int
    SolidBroken: int
    BrokenSolid: int
    BrokenBroken: int
    BottsDots: int
    Grass: int
    Curb: int
class LaneType(IntFlag):
    NONE: int
    Driving: int
    Stop: int
    Shoulder: int
    Biking: int
    Sidewalk: int
    Border: int
    Restricted: int
    Parking: int
    Bidirectional: int
    Median: int
    Special1: int
    Special2: int
    Special3: int
    RoadWorks: int
    Tram: int
    Rail: int
    Entry: int
    Exit: int
    OffRamp: int
    OnRamp: int
    Any: int
class LightGroup(IntEnum):
    NONE: int
    Vehicle: int
    Street: int
    Building: int
    Other: int
class Light:
    color: Color
    id: int
    intensity: float
    is_on: bool
    location: Location
    light_group: LightGroup
    light_state: LightState
    def turn_off(self) -> None: ...
    def turn_on(self) -> None: ...
    def set_color(self, color: Color) -> None: ...
    def set_intensity(self, intensity: float) -> None: ...
    def set_light_group(self, light_group: LightGroup) -> None: ...
    def set_light_state(self, light_state: LightState) -> None: ...
class LightManager:
    def is_active(self, lights: List[Light]) -> List[bool]: ...
    def turn_off(self, lights: List[Light]) -> None: ...
    def turn_on(self, lights: List[Light]) -> None: ...
    def get_all_lights(self, light_group: LightGroup = LightGroup.NONE) -> List[Light]: ...
    def get_intensity(self, lights: List[Light]) -> List[float]: ...
    def get_light_group(self, lights: List[Light]) -> List[LightGroup]: ...
    def get_light_state(self, lights: List[Light]) -> List[LightState]: ...
    def get_turned_off_lights(self, light_group: LightGroup) -> List[Light]: ...
    def get_turned_on_lights(self, light_group: LightGroup) -> List[Light]: ...
    def set_active(self, lights: List[Light], active: List[bool]) -> None: ...
    def set_color(self, lights: List[Light], color: Color) -> None: ...
    def set_colors(self, lights: List[Light], colors: List[Color]) -> None: ...
    def set_intensities(self, lights: List[Light], intensities: List[float]) -> None: ...
    def set_intensity(self, lights: List[Light], intensity: float) -> None: ...
    def set_light_group(self, lights: List[Light], light_group: LightGroup) -> None: ...
    def set_light_groups(self, lights: List[Light], light_groups: List[LightGroup]) -> None: ...
    def set_light_state(self, lights: List[Light], light_state: LightState) -> None: ...
    def set_light_states(self, lights: List[Light], light_states: List[LightState]) -> None: ...
class LightState:
    intensity: float
    color: Color
    group: LightGroup
    active: bool
    def __init__(self,
                 intensity: float = 0.0,
                 color: Color = Color(),
                 group: LightGroup = LightGroup.NONE,
                 active: bool = False) -> None: ...
class Location(Vector3D):
    def __init__(self, x: float = 0, y: float = 0, z: float = 0) -> None: ...
    def distance(self, location: Location) -> float: ...
    def __abs__(self) -> Location: ...
    def __eq__(self, other: Location) -> bool: ...
    def __ne__(self, other: Location) -> bool: ...
    def __str__(self) -> str: ...
    def __add__(self, other: Location) -> Location: ...
class Map:
    name: str
    def __init__(self,
                 name: str,
                 xodr_content: str) -> None: ...
    def generate_waypoints(self, distance: float) -> List[Waypoint]: ...
    def save_to_disk(self, path: str) -> None: ...
    def to_opendrive(self) -> str: ...
    def transform_to_geolocation(self, location: Location) -> GeoLocation: ...
    def get_all_landmarks(self) -> List[Landmark]: ...
    def get_all_landmarks_from_id(self, opendrive_id: str) -> List[Landmark]: ...
    def get_all_landmarks_of_type(self, type: str) -> List[Landmark]: ...
    def get_crosswalks(self) -> List[Location]: ...
    def get_landmark_group(self, landmark: Landmark) -> List[Landmark]: ...
    def get_spawn_points(self) -> List[Transform]: ...
    def get_topology(self) -> list[tuple[Waypoint, Waypoint]]: ...
    def get_waypoint(self,
                     location: Location,
                     project_to_road: Optional[bool] = True,
                     lane_type: LaneType = LaneType.Driving) -> Optional[Waypoint]: ...
    def get_waypoint_xodr(self,
                          road_id: int,
                          lane_id: int,
                          s: float) -> Waypoint: ...
    def __str__(self) -> str: ...
class MapLayer(IntEnum):
    NONE: int
    Buildings: int
    Decals: int
    Foliage: int
    Ground: int
    ParkedVehicles: int
    Particles: int
    Props: int
    StreetLights: int
    Walls: int
    All: int
class MaterialParameter(IntEnum):
    Normal: int
    Diffuse: int
    AO_Roughness_Metallic_Emissive: int
    Emissive: int
class OpendriveGenerationParameters:
    vertex_distance: float
    max_road_length: float
    wall_height: float
    additional_width: float
    smooth_junctions: bool
    enable_mesh_visibility: bool
    enable_pedestrian_navigation: bool
class Rotation:
    pitch: float
    yaw: float
    roll: float
    def __init__(self, pitch: float = 0, yaw: float = 0, roll: float = 0) -> None: ...
    def get_forward_vector(self) -> Vector3D: ...
    def get_right_vector(self) -> Vector3D: ...
    def get_up_vector(self) -> Vector3D: ...
    def __eq__(self, other: Rotation) -> bool: ...
    def __ne__(self, other: Rotation) -> bool: ...
    def __str__(self) -> str: ...
class Sensor(Actor):
    is_listening: bool
    def listen(self, callback: Callable[[SensorData], None]) -> None: ...
    def stop(self) -> None: ...
    def __str__(self) -> str: ...
class SensorData:
    frame: int
    timestamp: float
    transform: Transform
class TextureColor:
    width: int
    height: int
    def __init__(self, width: int, height: int) -> None: ...
    def get(self, x: int, y: int) -> Color: ...
    def set(self, x: int, y: int, value: Color) -> None: ...
    def set_dimensions(self, width: int, height: int) -> None: ...
class TextureFloatColor:
    width: int
    height: int
    def __init__(self, width: int, height: int) -> None: ...
    def get(self, x: int, y: int) -> FloatColor: ...
    def set(self, x: int, y: int, value: FloatColor) -> None: ...
    def set_dimensions(self, width: int, height: int) -> None: ...
class Timestamp:
    frame: int
    elapsed_seconds: float
    delta_seconds: float
    platform_timestamp: float
    def __init__(self,
                 frame: int,
                 elapsed_seconds: float,
                 delta_seconds: float,
                 platform_timestamp: float) -> None: ...
    def __eq__(self, other: Timestamp) -> bool: ...
    def __ne__(self, other: Timestamp) -> bool: ...
    def __str__(self) -> str: ...
class TrafficLight(TrafficSign)(Actor):
    state: TrafficLightState
    def freeze(self, freeze: bool) -> None: ...
    def is_frozen(self) -> bool: ...
    def reset_group(self) -> None: ...
    def get_affected_lane_waypoints(self) -> List[Waypoint]: ...
    def get_elapsed_time(self) -> float: ...
    def get_green_time(self) -> float: ...
    def get_group_traffic_lights(self) -> List[TrafficLight]: ...
    def get_light_boxes(self) -> List[BoundingBox]: ...
    def get_opendrive_id(self) -> str: ...
    def get_pole_index(self) -> int: ...
    def get_red_time(self) -> float: ...
    def get_state(self) -> TrafficLightState: ...
    def get_stop_waypoints(self) -> List[Waypoint]: ...
    def get_yellow_time(self) -> float: ...
    def set_green_time(self, green_time: float) -> None: ...
    def set_red_time(self, red_time: float) -> None: ...
    def set_state(self, state: TrafficLightState) -> None: ...
    def set_yellow_time(self, yellow_time: float) -> None: ...
    def __str__(self) -> str: ...
class TrafficLightState(IntEnum):
    Red: int
    Yellow: int
    Green: int
    Off: int
    Unknown: int    
class TrafficManager:
    def auto_lane_change(self,
                         actor: Actor,
                         enable: bool) -> None: ...
    def auto_update_lights(self,
                           actor: Actor,
                           do_update: bool) -> None: ...
    def collision_detection(self,
                            reference_actor: Actor,
                            other_actor: Actor,
                            detect_collision: bool) -> None: ...
    def distance_to_leading_vehicle(self,
                                    actor: Actor,
                                    distance: float) -> None: ...
    def force_lane_change(self,
                          actor: Actor,
                          direction: bool) -> None: ...
    def global_percentage_speed_difference(self, percentage: float) -> None: ...
    def ignore_lights_percentage(self,
                                 actor: Actor,
                                 perc: float) -> None: ...
    def ignore_signs_percentage(self,
                                actor: Actor,
                                perc: float) -> None: ...
    def ignore_vehicles_percentage(self,
                                   actor: Actor,
                                   perc: float) -> None: ...
    def ignore_walkers_percentage(self,
                                  actor: Actor,
                                  perc: float) -> None: ...
    def vehicle_percentage_speed_difference(self,
                                            actor: Actor,
                                            percentage: float) -> None: ...
    def get_port(self) -> int: ...
    def set_boundaries_respawn_dormant_vehicles(self,
                                                lower_bound: float = 25.0,
                                                upper_bound: float = ... # actor_active_distance
                                                ) -> None: ...
    def set_global_distance_to_leading_vehicle(self, distance: float) -> None: ...
    def set_hybrid_physics_mode(self, enabled: bool = False) -> None: ...
    def set_hybrid_physics_radius(self, r: float = 50.0) -> None: ...
    def set_osm_mode(self, mode_switch: bool = True) -> None: ...
    def keep_right_rule_percentage(self,
                                   actor: Actor,
                                   perc: float) -> None: ...
    def set_random_device_seed(self, value: int) -> None: ...
    def set_respawn_dormant_vehicles(self, mode_switch: bool = False) -> None: ...
    def set_synchronous_mode(self, mode_switch: bool = True) -> None: ...
    # v0.9.14
    def random_left_lanechange_percentage(self,
                                          actor: Actor,
                                          percentage: float) -> None: ...
    def random_right_lanechange_percentage(self,
                                           actor: Actor,
                                           percentage: float) -> None: ...
class TrafficSign(Actor):
    trigger_volume: BoundingBox
class Transform:
    location: Location
    rotation: Rotation
    def __init__(self, location: Location, rotation: Rotation) -> None: ...
    def transform(self, in_point: Location) -> Location: ...
    def get_forward_vector(self) -> Vector3D: ...
    def get_inverse_matrix(self) -> List[List[float]]: ...
    def get_matrix(self) -> List[List[float]]: ...
    def get_right_vector(self) -> Vector3D: ...
    def get_up_vector(self) -> Vector3D: ...
    def __eq__(self, other: Transform) -> bool: ...
    def __ne__(self, other: Transform) -> bool: ...
    def __str__(self) -> str: ...
class Vector2D:
    x: float
    y: float
    def __init__(self, x: float = 0, y: float = 0) -> None: ...
    def length(self) -> float: ...
    def make_unit_vector(self) -> Vector3D: ...
    def squared_length(self) -> float: ...
    def __add__(self, other: Vector2D) -> None: ...
    def __eq__(self, other: Vector2D) -> bool: ...
    def __mul__(self, other: Vector2D) -> None: ...
    def __ne__(self, other: Vector2D) -> bool: ...
    def __str__(self) -> str: ...
    def __sub__(self, other: Vector2D) -> None: ...
    def __truediv__(self, other: Vector2D) -> None: ...
class Vector3D:
    x: float
    y: float
    z: float
    def __init__(self, x: float = 0, y: float = 0, z: float = 0) -> None: ...
    def cross(self, vector: Vector3D) -> Vector3D: ...
    def distance(self, vector: Vector3D) -> float: ...
    def distance_2d(self, vector: Vector3D) -> float: ...
    def distance_squared(self, vector: Vector3D) -> float: ...
    def distance_squared_2d(self, vector: Vector3D) -> float: ...
    def dot(self, vector: Vector3D) -> float: ...
    def dot_2d(self, vector: Vector3D) -> float: ...
    def length(self) -> float: ...
    def make_unit_vector(self) -> Vector3D: ...
    def squared_length(self) -> float: ...
    def __abs__(self) -> Vector3D: ...
    def __add__(self, other: Vector3D) -> None: ...
    def __eq__(self, other: Vector3D) -> bool: ...
    def __mul__(self, other: Vector3D) -> None: ...
    def __ne__(self, other: Vector3D) -> bool: ...
    def __str__(self) -> str: ...
    def __sub__(self, other: Vector3D) -> None: ...
    def __truediv__(self, other: Vector3D) -> None: ...
class Vehicle(Actor):
    bounding_box: BoundingBox
    def apply_control(self, control: VehicleControl) -> None: ...
    def apply_physics_control(self, physics_control: VehiclePhysicsControl) -> None: ...
    def enable_carsim(self, simfile_path: str) -> None: ...
    def is_at_traffic_light(self) -> bool: ...
    def use_carsim_road(self, enabled: bool) -> None: ...
    def get_control(self) -> VehicleControl: ...
    def get_light_state(self) ->  VehicleLightState: ...
    def get_physics_control(self) -> VehiclePhysicsControl: ...
    def get_speed_limit(self) -> float: ...
    def get_traffic_light(self) -> TrafficLight: ...
    def get_traffic_light_state(self) -> TrafficLightState: ...
    def get_wheel_steer_angle(self, wheel_location: VehicleWheelLocation) -> float: ...
    def set_autopilot(self, value: bool) -> None: ...
    def set_light_state(self, light_state: VehicleLightState) -> None: ...
    def set_wheel_steer_direction(self,
                                  wheel_location: VehicleWheelLocation,
                                  angle_in_deg: float) -> None: ...
    def __str__(self) -> str: ...
class VehicleControl:
    throttle: float
    steer: float
    brake: float
    hand_brake: bool
    reverse: bool
    manual_gear_shift: bool
    gear: int
    def __init__(self,
                 throttle: float = 0.0,
                 steer: float = 0.0,
                 brake: float = 0.0,
                 hand_brake: bool = False,
                 reverse: bool = False,
                 manual_gear_shift: bool = False,
                 gear: int = 0) -> None: ...
    def __eq__(self, other: VehicleControl) -> bool: ...
    def __ne__(self, other: VehicleControl) -> bool: ...
    def __str__(self) -> str: ...
class VehicleDoor(IntEnum):
    FL: int
    FR: int
    RL: int
    RR: int
    All: int
class VehicleLightState(IntEnum):
    NONE: int
    Position: int
    LowBeam: int
    HighBeam: int
    Brake: int
    RightBlinker: int
    LeftBlinker: int
    Reverse: int
    Fog: int
    Interior: int
    Special1: int
    Special2: int
    All: int
class VehiclePhysicsControl:
    torque_curve: List[Vector2D]
    max_rpm: float
    moi: float
    damping_rate_full_throttle: float
    damping_rate_zero_throttle_clutch_engaged: float
    damping_rate_zero_throttle_clutch_disengaged: float
    use_gear_autobox: bool
    gear_switch_time: float
    clutch_strength: float
    final_ratio: float
    forward_gears: List[GearPhysicsControl]
    mass: float
    drag_coefficient: float
    center_of_mass: Vector3D
    steering_curve: List[Vector2D]
    use_sweep_wheel_collision: bool
    wheels: List[WheelPhysicsControl]
    def __init__(self, 
                 torque_curve: List[Vector2D] = [Vector2D(0.0, 500.0), Vector2D(5000.0, 500.0)],
                 max_rpm: float = 5000.0,
                 moi: float = 1.0,
                 damping_rate_full_throttle: float = 0.15,
                 damping_rate_zero_throttle_clutch_engaged: float = 2.0,
                 damping_rate_zero_throttle_clutch_disengaged: float = 0.35,
                 use_gear_autobox: bool = True,
                 gear_switch_time: float = 0.5,
                 clutch_strength: float = 10.0,
                 final_ratio: float = 4.0,
                 forward_gears: List[GearPhysicsControl] = [],
                 drag_coefficient: float = 0.3,
                 center_of_mass: Vector3D = Vector3D(),
                 steering_curve: List[Vector2D] = [Vector2D(0.0, 1.0), Vector2D(10.0, 0.5)],
                 wheels: List[WheelPhysicsControl] = [],
                 use_sweep_wheel_collision: bool = False,
                 mass: float = 1000.0) -> None: ...
    def __eq__(self, other: VehiclePhysicsControl) -> bool: ...
    def __ne__(self, other: VehiclePhysicsControl) -> bool: ...
    def __str__(self) -> str: ...
class VehicleWheelLocation(IntEnum):
    FL_Wheel: int
    FR_Wheel: int
    BL_Wheel: int
    BR_Wheel: int
    Front_Wheel: int
    Back_Wheel: int
class Waypoint:
    id: int
    transform: Transform
    road_id: int
    section_id: int
    lane_id: int
    s: float
    is_junction: bool
    lane_width: float
    lane_change: LaneChange
    lane_type: LaneType
    right_lane_marking: LaneMarking
    left_lane_marking: LaneMarking
    def next(self, distance: float) -> List[Waypoint]: ...
    def next_until_lane_end(self, distance: float) -> List[Waypoint]: ...
    def previous(self, distance: float) -> List[Waypoint]: ...
    def previous_until_lane_start(self, distance: float) -> List[Waypoint]: ...
    def get_junction(self) -> Optional[Junction]: ...
    def get_landmarks(self,
                      distance: float,
                      stop_at_junction: bool = False) -> List[Landmark]: ...
    def get_landmarks_of_type(self,
                              distance: float,
                              type: str,
                              stop_at_junction: bool = False) -> List[Landmark]: ...
    def get_left_lane(self) -> Optional[Waypoint]: ...
    def get_right_lane(self) -> Optional[Waypoint]: ...
    def __str__(self) -> str: ...
class WeatherParameters:
    cloudiness: float
    precipitation: float
    precipitation_deposits: float
    wind_intensity: float
    sun_azimuth_angle: float
    sun_altitude_angle: float
    fog_density: float
    fog_distance: float
    wetness: float
    fog_falloff: float
    scattering_intensity: float
    mie_scattering_scale: float
    rayleigh_scattering_scale: float
    def __init__(self,
                 cloudiness: float = 0.0,
                 recipitation: float = 0.0,
                 precipitation_deposits: float = 0.0,
                 wind_intensity: float = 0.0,
                 sun_azimuth_angle: float = 0.0,
                 sun_altitude_angle: float = 0.0,
                 fog_density: float = 0.0,
                 fog_distance: float = 0.0,
                 wetness: float = 0.0,
                 fog_falloff: float = 0.0,
                 scattering_intensity: float = 0.0,
                 mie_scattering_scale: float = 0.0,
                 rayleigh_scattering_scale: float = 0.0331) -> None: ...
    def __eq__(self, other: WeatherParameters) -> bool: ...
    def __ne__(self, other: WeatherParameters) -> bool: ...
    def __str__(self) -> str: ...
class WheelPhysicsControl:
    tire_friction: float
    damping_rate: float
    max_steer_angle: float
    radius: float
    max_brake_torque: float
    max_handbrake_torque: float
    position: Vector3D
    long_stiff_value: float
    lat_stiff_max_load: float
    lat_stiff_value: float
    def __init__(self,
                 tire_friction: float = 2.0,
                 damping_rate: float = 0.25,
                 max_steer_angle: float = 70.0,
                 radius: float = 30.0,
                 max_brake_torque: float = 1500.0,
                 max_handbrake_torque: float = 3000.0,
                 position: Vector3D = Vector3D(0.0,0.0,0.0)) -> None: ...
    def __eq__(self, other: WheelPhysicsControl) -> bool: ...
    def __ne__(self, other: WheelPhysicsControl) -> bool: ...
    def __str__(self) -> str: ...
class World:
    id: int
    debug: DebugHelper
    def apply_color_texture_to_object(self,
                                      object_name: str,
                                      material_parameter: MaterialParameter,
                                      texture: TextureColor) -> None: ...
    def apply_color_texture_to_objects(self,
                                       objects_name_list: List[str],
                                       material_parameter: MaterialParameter,
                                       texture: TextureColor) -> None: ...
    def apply_float_color_texture_to_object(self,
                                            object_name: str,
                                            material_parameter: MaterialParameter,
                                            texture: TextureColor) -> None: ...
    def apply_float_color_texture_to_objects(self,
                                             objects_name_list: List[str],
                                             material_parameter: MaterialParameter,
                                             texture: TextureColor) -> None: ...
    def apply_settings(self, world_settings: WorldSettings) -> int: ...
    def apply_textures_to_object(self,
                                 object_name: str,
                                 diffuse_texture: TextureColor,
                                 emissive_texture: TextureFloatColor,
                                 normal_texture: TextureFloatColor,
                                 ao_roughness_metallic_emissive_texture: TextureFloatColor) -> None: ...
    def apply_textures_to_objects(self,
                                  objects_name_list: List[str],
                                  diffuse_texture: TextureColor,
                                  emissive_texture: TextureFloatColor,
                                  normal_texture: TextureFloatColor,
                                  ao_roughness_metallic_emissive_texture: TextureFloatColor) -> None: ...
    def cast_ray(self,
                 initial_location: Location,
                 final_location: Location) -> List[LabelledPoint]: ...
    def enable_environment_objects(self,
                                   env_objects_ids: Set[int],
                                   enable: bool) -> None: ...
    def freeze_all_traffic_lights(self, frozen: bool) -> None: ...
    def ground_projection(self,
                          location: Location,
                          search_distance: float) -> LabelledPoint: ...
    def load_map_layer(self, map_layers: MapLayer) -> None: ...

    def on_tick(self, callback: Callable[[WorldSnapshot], None]) -> int: ...
    def project_point(self,
                      location: Location,
                      direction: Vector3D,
                      search_distance: float) -> LabelledPoint: ...
    def remove_on_tick(self, callback_id: int) -> None: ...
    def reset_all_traffic_lights(self) -> None: ...
    def spawn_actor(self,
                    blueprint: ActorBlueprint,
                    transform: Transform,
                    attach_to:  Optional[Actor] = None,
                    attachment: AttachmentType = AttachmentType.Rigid) -> Actor: ...
    def tick(self, seconds: float = 10.0) -> int: ...
    def try_spawn_actor(self,
                        blueprint: ActorBlueprint,
                        transform: Transform,
                        attach_to: Optional[Actor] = None,
                        attachment: AttachmentType = AttachmentType.Rigid) -> Actor: ...
    def unload_map_layer(self, map_layers: MapLayer) -> None: ...
    def wait_for_tick(self, seconds: float = 10.0) -> WorldSnapshot: ...
    def get_actor(self, actor_id: int) -> Actor: ...
    def get_actors(self, actor_ids: Optional[List[int]] = None) -> ActorList: ...
    def get_blueprint_library(self) -> BlueprintLibrary: ...
    def get_environment_objects(self, object_type: CityObjectLabel = CityObjectLabel.Any) -> List[EnvironmentObject]: ...
    def get_level_bbs(self, actor_type: CityObjectLabel = CityObjectLabel.Any) -> List[BoundingBox]: ...
    def get_lightmanager(self) -> LightManager: ...
    def get_map(self) -> Map: ...
    def get_names_of_all_objects(self) -> List[str]: ...
    def get_random_location_from_navigation(self) -> Location: ...
    def get_settings(self) -> WorldSettings: ...
    def get_snapshot(self) -> WorldSnapshot: ...
    def get_spectator(self) -> Actor: ...
    def get_traffic_light(self, landmark: Landmark) -> TrafficLight: ...
    def get_traffic_lights_from_waypoint(self,
                                         waypoint: Waypoint,
                                         distance: float) -> List[TrafficLight]: ...
    def get_traffic_lights_in_junction(self, junction_id: int) -> List[TrafficLight]: ...
    def get_traffic_sign(self, landmark: Landmark) -> TrafficSign: ..(Actor).
    def get_vehicles_light_states(self) -> dict[Actor, VehicleLightState]: ...
    def get_weather(self) -> WeatherParameters: ...
    def set_pedestrians_cross_factor(self, percentage: float) -> None: ...
    def set_pedestrians_seed(self, seed: int) -> None: ...
    def set_weather(self, weather: WeatherParameters) -> None: ...
    def __str__(self) -> str: ...
class WorldSettings:
    synchronous_mode: bool
    no_rendering_mode: bool
    fixed_delta_seconds: float
    substepping: bool
    max_substep_delta_time: float
    max_substeps: int
    max_culling_distance: float
    deterministic_ragdolls: bool
    tile_stream_distance: float
    actor_active_distance: float
    def __init__(self,
                 synchronous_mode: bool = False,
                 no_rendering_mode: bool = False,
                 fixed_delta_seconds: float = 0.0) -> None: ...
    def __eq__(self, other: WorldSettings) -> bool: ...
    def __ne__(self, other: WorldSettings) -> bool: ...
    def __str__(self) -> str: ...
class WorldSnapshot:
    id: int
    frame: int
    timestamp: Timestamp
    def find(self, actor_id: int) -> ActorSnapshot: ...
    def has_actor(self, actor_id: int) -> bool: ...
    def __eq__(self, other: WorldSnapshot) -> bool: ...
    def __ne__(self, other: WorldSnapshot) -> bool: ...
    def __iter__(self) -> Iterator[ActorSnapshot]: ...
    def __len__(self) -> int: ...
