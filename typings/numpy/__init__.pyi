"""
Numpy's mypy stub. Only type declarations for ndarray, the scalar hierarchy and array creation
methods are provided.
"""

from typing import (Any, Callable, Dict, Generic, Iterator, List, Optional, Sequence, Tuple, Type,
                    TypeVar, Union)
import numpy

class dtype:
    def __init__(self, type: numpy.DtypeType) -> None: ...
    ...
_dtype = dtype


class flagsobj:
    """numpy.flagsobj"""
    aligned: Optional[bool] = None
    behaved: Optional[bool] = None
    c_contiguous: Optional[bool] = None
    carray: Optional[bool] = None
    contiguous: Optional[bool] = None
    f_contiguous: Optional[bool] = None
    farray: Optional[bool] = None
    fnc: Optional[bool] = None
    forc: Optional[bool] = None
    fortran: Optional[bool] = None
    owndata: Optional[bool] = None
    updateifcopy: Optional[bool] = None
    writeable: Optional[bool] = None
    def __getitem__(self, item: str) -> bool: ...
    def __setitem__(self, item: str, value: bool) -> None: ...

#
# Type variables. _T wasn't used to avoid confusions with ndarray's "T" attribute.
#

_S = TypeVar('_S')
_U = TypeVar('_U')
_V = TypeVar('_V')

#
# Auxiliary types
#

ShapeType = Union[int, Tuple[int, ...]]
AxesType = Union[int, Tuple[int, ...]]
OrderType = Union[str, Sequence[str]]
DtypeType = Union[dtype, type]

class flatiter(Generic[_S], Iterator[_S]):
    coords: ShapeType
    def copy(self) -> flatiter[_S]: ...

class ArrayLike(Generic[_S]):
    """
    "array-like" interface that both numpy.ndarray and all scalars (descendants of numpy.generic)
    implement this interface.
    """
    #
    # Array-like structures attributes
    #
    T: Optional[ArrayLike[_S]] = None
    data: Any = None
    dtype: Optional[_dtype] = None
    flags: Optional[flagsobj] = None
    flat: Optional[flatiter[ArrayLike[_S]]] = None
    imag: Optional[ArrayLike[_S]] = None
    real: Optional[ArrayLike[_S]] = None
    size: Optional[int] = None
    itemsize: Optional[int] = None
    nbytes: Optional[int] = None
    ndim: Optional[int] = None
    shape: Optional[Tuple[int, ...]] = None
    strides: Optional[Tuple[int, ...]] = None
    base: Optional[ArrayLike[_S]] = None

    #
    # Array-like methods
    #

    # Once this issue https://github.com/python/mypy/issues/1907 is resolved, most methods that
    # have an 'out' argument, will be implemented using overload instead of with a Union
    # result. mypy is smart enough to assign the proper type (_ArrayLike[_U]) when out is present
    # but it falls back to the union when it's not.
    def all(self, axis: Optional[AxesType]=None, out: 'Optional[ArrayLike[_U]]'=None,
            keepdims: bool=False) -> Union['ArrayLike[_U]', 'ArrayLike[bool]']: ...

    def any(self, axis: Optional[AxesType]=None, out: 'Optional[ArrayLike[_U]]'=None,
            keepdims: bool=False) -> Union['ArrayLike[_U]', 'ArrayLike[bool]']: ...

    def argmax(self, axis: Optional[int]=None,
               out: 'Optional[ArrayLike[_U]]'=None) -> Union['ArrayLike[_U]', 'ArrayLike[int]']: ...

    def argmin(self, axis: Optional[int]=None,
               out: 'Optional[ArrayLike[_U]]'=None) -> Union['ArrayLike[_U]', 'ArrayLike[int]']: ...

    def argpartition(self, kth: Union[int, Sequence[int]], axis: Optional[int]=-1,
                     kind: str='introselect', order: Optional[OrderType]=None) -> 'ArrayLike[int]': ...

    def argsort(self, axis: Optional[int]=None, kind: str='quicksort',
                order: Optional[OrderType]=None) -> 'ArrayLike[int]': ...

    def astype(self, dtype: Any, order: str='K', casting: str='unsafe', subok: bool=True,
               copy: bool=False) -> 'ArrayLike[Any]': ...

    def byteswap(self, inplace: bool=False) -> 'ArrayLike[_S]': ...

    def choose(self, choices:Sequence['ArrayLike[_V]'], out: 'Optional[ArrayLike[_U]]'=None,
               mode: str='raise') ->  Union['ArrayLike[_U]', 'ArrayLike[_V]']: ...

    def clip(self, a_min: Any, a_max: Any,
             out: 'Optional[ArrayLike[_U]]'=None) -> Union['ArrayLike[_S]', 'ArrayLike[_U]']: ...

    def compress(self, condition: Sequence[bool], axis: Optional[int]=None,
                 out: 'Optional[ArrayLike[_U]]'=None) -> Union['ArrayLike[_S]', 'ArrayLike[_U]']: ...

    def conj(self) -> 'ArrayLike[_S]': ...

    def conjugate(self) -> 'ArrayLike[_S]': ...

    def copy(self, order: str='C') -> 'ArrayLike[_S]': ...

    def cumprod(self, axis: Optional[int]=None, dtype: Any=None,
                out: 'Optional[ArrayLike[Any]]'=None) -> 'ArrayLike[Any]': ...

    def cumsum(self, axis: Optional[int]=None, dtype: Optional[DtypeType]=None,
                out: 'Optional[ArrayLike[Any]]'=None) -> 'ArrayLike[Any]': ...

    def diagonal(self, offset: int=0, axis1: int=0, axis2: int=1) -> 'ArrayLike[_S]': ...

    def dot(self, b: 'ArrayLike[Any]', out: 'Optional[ArrayLike[Any]]'=None) -> 'ArrayLike[Any]': ...

    def dump(self, file: str) -> None: ...

    def dumps(self) -> str: ...

    def fill(self, value: _S) -> None: ...

    def flatten(self, order: str='C') -> 'ArrayLike[_S]': ...

    def getfield(self, dtype: DtypeType, offset: int=0) -> 'ArrayLike[Any]': ...

    def item(self, args: AxesType) -> generic[_S]: ...

    def itemset(self, arg0: Union[int, Tuple[int, ...]], arg1: Any=None) -> None: ...

    def max(self, axis: Optional[AxesType]=None,
            out: 'Optional[ArrayLike[_U]]'=None) -> Union['ArrayLike[_S]', 'ArrayLike[_U]']: ...

    def mean(self, axis: Optional[AxesType]=None, dtype: Any=None,
             out: 'Optional[ArrayLike[Any]]'=None, keepdims: bool=False) -> 'ArrayLike[floating]': ...

    def min(self, axis: Optional[AxesType]=None,
            out: 'Optional[ArrayLike[_U]]'=None) -> Union['ArrayLike[_S]', 'ArrayLike[_U]']: ...

    def newbyteorder(self, new_order: str='S') -> 'ArrayLike[_S]': ...

    def nonzero(self) -> 'ArrayLike[int]': ...

    def partition(self, kth: AxesType, axis: int=-1, kind: str='introselect',
                  order: Optional[OrderType]=None) -> None: ...

    def prod(self, axis: Optional[AxesType]=None, dtype: Optional[DtypeType]=None,
             out: 'Optional[ArrayLike[Any]]'=None, keepdims: bool=False) -> 'ArrayLike[Any]': ...

    def ptp(self, axis: Optional[int]=None,
            out: 'Optional[ArrayLike[_U]]'=None) -> Union['ArrayLike[_S]', 'ArrayLike[_U]']: ...

    def put(self, ind: 'ArrayLike[int]', v: 'ArrayLike[_S]', mode: str='raise') -> None: ...

    def ravel(self, order: str='C') -> 'ArrayLike[_S]': ...

    def repeat(self, repeats: Union[int, Sequence[int]],
               axis: Optional[int]=None) -> 'ArrayLike[_S]': ...

    def reshape(self, newshape: ShapeType,
                order: str='C') -> 'ArrayLike[_S]': ...

    def resize(self, new_shape: ShapeType, refcheck: bool=True) -> None: ...

    def round(self, decimals: int=0,
              out: 'Optional[ArrayLike[_U]]'=None) -> Union['ArrayLike[_S]', 'ArrayLike[_U]']: ...

    def searchsorted(self, v: Union[_S, 'ArrayLike[_S]'], side: str='left',
                     sorter: 'Optional[ArrayLike[int]]'=None) -> 'ArrayLike[int]': ...

    def setfield(self, val: Any, dtype: DtypeType, offset: int=0) -> None: ...

    def setflags(self, write: Optional[bool]=None, align: Optional[bool]=None,
                 uic: Optional[bool]=None) -> None: ...

    def sort(self, axis: int=-1, kind: str='quicksort', order: Optional[OrderType]=None) -> None: ...

    def squeeze(self, axis: Optional[AxesType]=None) -> 'ArrayLike[_S]': ...

    def std(self, axis: Optional[AxesType]=None, dtype: Optional[DtypeType]=None,
            out: 'Optional[ArrayLike[Any]]'=None, ddof: int=0, keepdims: bool=False) -> 'ArrayLike[floating]': ...

    def sum(self, axis: Optional[AxesType]=None, dtype: Optional[DtypeType]=None,
            out: 'Optional[ArrayLike[Any]]'=None,
            keepdims: bool=False) -> 'ArrayLike[Any]': ...

    def swapaxes(self, axis1: int, axis2: int) -> 'ArrayLike[_S]': ...

    def take(self, indices: Sequence[int], axis: Optional[int]=None,
             out: 'Optional[ArrayLike[_U]]'=None,
             mode: str='raise') -> Union['ArrayLike[_S]', 'ArrayLike[_U]']: ...

    def tobytes(self, order: str='C') -> bytes: ...

    def tofile(self, fid: object, sep: str='',  # TODO fix fid definition (There's a bug in mypy io's namespace https://github.com/python/mypy/issues/1462)
               format: str='%s') -> None: ...

    def tolist(self) -> List[Any]: ...

    def tostring(self, order: str='C') -> bytes: ...

    def trace(self, offset: int=0, axis1: int=0, axis2: int=1,
              dtype: Optional[DtypeType]=None, out: 'Optional[ArrayLike[Any]]'=None) -> 'ArrayLike[Any]': ...

    def transpose(self, axes: Optional[AxesType]) -> 'ArrayLike[_S]': ...

    def var(self, axis: Optional[AxesType]=None, dtype: Optional[DtypeType]=None,
            out: 'Optional[ArrayLike[Any]]'=None, ddof: int=0, keepdims: bool=False) -> 'ArrayLike[Any]': ...

    def view(self, dtype: Optional[DtypeType]=None,
             type: Optional[type]=None) -> 'ArrayLike[Any]': ...
    
    #
    # Magic methods
    #

    def __abs__(self) -> 'ArrayLike[_S]': ...

    def __add__(self, value: object) -> 'ArrayLike[Any]': ...

    def __and__(self, value: object) -> 'ArrayLike[int]': ...

    def __array__(self, dtype: Optional[DtypeType]=None) -> 'ArrayLike[Any]': ...

    def __array_prepare__(self, context: object=None) -> 'ArrayLike[Any]': ...

    def __array_wrap__(self, context: object=None) -> 'ArrayLike[Any]': ...

    def __bool__(self) -> bool: ...

    def __complex__(self) -> complex: ...

    def __contains__(self, key: object) -> bool: ...

    def __copy__(self) -> 'ArrayLike[_S]': ...

    def __deepcopy__(self) -> 'ArrayLike[_S]': ...

    def __delattr__(self, name: str) -> None: ...

    def __delitem__(self, key: str) -> None: ...

    def __dir__(self) -> List[str]: ...

    def __divmod__(self, value: object) -> Tuple['ArrayLike[int]', 'ArrayLike[float]']: ...

    def __eq__(self, value: object) -> 'ArrayLike[bool]': ...  # type: ignore

    def __float__(self) -> float: ...

    def __floordiv__(self, value: object) -> 'ArrayLike[int]': ...

    def __ge__(self, value: object) -> 'ArrayLike[bool]': ...

    def __getattribute__(self, name: str) -> Any: ...

    def __getitem__(self, key: Any) -> 'ArrayLike[_S]': ...

    def __gt__(self, value: object) -> 'ArrayLike[bool]': ...

    def __iadd__(self, value: object) -> None: ...

    def __iand__(self, value: object) -> None: ...

    def __ifloordiv__(self, value: object) -> None: ...

    def __ilshift__(self, value: object) -> None: ...

    def __imatmul__(self, value: 'ArrayLike[Any]') -> None: ...

    def __imod__(self, value: object) -> None: ...

    def __imul__(self, value: object) -> None: ...

    def __index__(self) -> int: ...

    def __int__(self) -> int: ...

    def __invert__(self) -> 'ArrayLike[_S]': ...

    def __ior__(self, value: object) -> None: ...

    def __ipow__(self, value: object) -> None: ...

    def __irshift__(self, value: object) -> None: ...

    def __isub__(self, value: object) -> None: ...

    def __iter__(self) -> Iterator['ArrayLike[_S]']: ...

    def __itruediv__(self, value: object) -> None: ...

    def __ixor__(self, value: object) -> None: ...

    def __le__(self, value: object) -> 'ArrayLike[bool]': ...

    def __len__(self) -> int: ...

    def __lshift__(self, value: object) -> 'ArrayLike[_S]': ...

    def __lt__(self, value: object) -> 'ArrayLike[bool]': ...

    def __matmul__(self, value: 'ArrayLike[Any]') -> 'ArrayLike[Any]': ...

    def __mod__(self, value: object) -> 'ArrayLike[_S]': ...

    def __mul__(self, value: object) -> 'ArrayLike[Any]': ...

    def __ne__(self, value: object) -> 'ArrayLike[bool]': ...  # type: ignore

    def __neg__(self) -> 'ArrayLike[_S]': ...

    def __or__(self, value: object) -> 'ArrayLike[_S]': ...

    def __pos__(self) -> 'ArrayLike[_S]': ...

    def __pow__(self, value: object) -> 'ArrayLike[Any]': ...

    def __radd__(self, value: object) -> 'ArrayLike[Any]': ...

    def __rand__(self, value: object) -> 'ArrayLike[_S]': ...

    def __rdivmod__(self, value: object) -> Tuple['ArrayLike[int]', 'ArrayLike[float]']: ...

    def __rfloordiv__(self, value: object) -> 'ArrayLike[Any]': ...

    def __rlshift__(self, value: object) -> 'ArrayLike[Any]': ...

    def __rmatmul__(self, value: object) -> 'ArrayLike[Any]': ...

    def __rmod__(self, value: object) -> 'ArrayLike[Any]': ...

    def __rmul__(self, value: object) -> 'ArrayLike[Any]': ...

    def __ror__(self, value: object) -> 'ArrayLike[_S]': ...

    def __rpow__(self, value: object) -> 'ArrayLike[Any]': ...

    def __rrshift__(self, value: object) -> 'ArrayLike[Any]': ...

    def __rshift__(self, value: object) -> 'ArrayLike[Any]': ...

    def __rsub__(self, value: object) -> 'ArrayLike[Any]': ...

    def __rtruediv__(self, value: object) -> 'ArrayLike[Any]': ...

    def __rxor__(self, value: object) -> 'ArrayLike[_S]': ...

    def __setattr__(self, name: str, value: Any) -> None: ...

    def __setitem__(self, key: Any, value: Any) -> None: ...

    def __str__(self) -> str: ...

    def __sub__(self, value: object) -> 'ArrayLike[Any]': ...

    def __truediv__(self, value: object) -> 'ArrayLike[Any]': ...

    def __xor__(self, value: object) -> 'ArrayLike[_S]': ...

#
# numpy's scalar hierarchy (http://docs.scipy.org/doc/numpy/reference/arrays.scalars.html#scalars)
#

class generic(ArrayLike[_S], Generic[_S]): ...
class bool_(generic[bool]): ...
bool8 = bool_
class object_(generic[Any]): ...
class number(generic[_S], Generic[_S]): ...
class integer(number[int]): ...
class signedinteger(integer): ...
class byte(signedinteger): ...
class short(signedinteger): ...
class intc(signedinteger): ...
class int_(signedinteger): ...
class longlong(signedinteger): ...
class int8(signedinteger): ...
class int16(signedinteger): ...
class int32(signedinteger): ...
class int64(signedinteger): ...
class unsignedinteger(integer): ...
class ubyte(unsignedinteger): ...
class ushort(unsignedinteger): ...
class uintc(unsignedinteger): ...
class uint(unsignedinteger): ...
class ulonglong(unsignedinteger): ...
class uint8(signedinteger): ...
class uint16(signedinteger): ...
class uint32(signedinteger): ...
class uint64(signedinteger): ...
class inexact(number[float]): ...
class floating(inexact): ...
class half(floating): ...
class single(floating): ...
class float_(floating): ...
class longfloat_(floating): ...
class float16(floating): ...
class float32(floating): ...
class float64(floating): ...
class float128(floating): ...
class complexfloating(inexact): ...
class csingle(complexfloating): ...
class complex_(complexfloating): ...
class clongfloat(complexfloating): ...
class complex64(complexfloating): ...
class complex128(complexfloating): ...
class complex256(complexfloating): ...
class flexible(generic[_S], Generic[_S]): ...
class character(flexible[str]): ...
class str_(character): ...
class unicode_(character): ...
class void(flexible[None]): ...

class ndarray(ArrayLike[_S], Generic[_S]):
    """numpy.ndarray"""
    ctypes: Any = None    # TODO Implement ctypes type hint

    # TODO Need to find a way to restrict buffer type
    def __init__(self, shape: Tuple[int, ...], dtype: Optional[DtypeType]=None,
                 buffer: Any=None, offset: Optional[int]=None,
                 strides: Optional[Tuple[int, ...]]=None, order: Optional[str]=None) -> None: ...

#
# Array creation routines
#

def array(object: Any, dtype: Any=None, copy: bool=True,
          order: Optional[str]=None, subok: bool=False,
          ndmin: int=0) -> ndarray[Any]: ...
def asarray(a: Any,
            dtype: Type[_S]=None,
            order: Optional[str]=None) -> ndarray[_S]: ...
def asanyarray(a: Any,
               dtype: Type[_S]=None,
               order: Optional[str]=None) -> ndarray[_S]: ...  # TODO figure out a way to restrict the return type
def asmatrix(data: Any, dtype: Type[_S]=None) -> _S: ...  # TODO define matrix
def ascontiguousarray(a: Any, dtype: Type[_S]=None) -> ndarray[_S]: ...
def copy(a: Any, order: Optional[str]=None)	-> ndarray[Any]: ...
def empty(shape: ShapeType, dtype: Type[_S]=float, order: str='C') -> ndarray[_S]: ...
def empty_like(a: Any, dtype: Any=None, order: str='K', subok: bool=True) -> ndarray[Any]: ...
def eye(N: int, M: Optional[int]=None, k: int=0, dtype: Type[_S]=float) -> ndarray[_S]: ...
def frombuffer(buffer: Union[bytes, bytearray, memoryview],
               dtype: Type[_S]=float,
               count: int=-1,
               offset: int=0) -> ndarray[_S]: ...
def fromfile(file: object,
             dtype: Type[_S]=float,
             count: int=-1,
             sep: str='') -> ndarray[_S]: ...  # TODO fix file definition (There's a bug in mypy io's namespace https://github.com/python/mypy/issues/1462)
def full(shape: ShapeType, fill_value: Any, dtype: Type[_S]=None,
         order: str='C') -> ndarray[_S]: ...
def full_like(a: Any, fill_value: Any, dtype: Type[_S]=None, order: str='C',
              subok: bool=True) -> ndarray[_S]: ...
def fromfunction(function: Callable[..., _S],
                 shape: ShapeType,
                 dtype: DtypeType=float) -> ndarray[_S]: ...
def fromiter(iterable: Iterator[Any], dytpe: DtypeType, count: int=-1) -> ndarray[Any]: ...
def fromstring(string: str,
               dtype: Type[_S]=float,
               count: int=-1,
               sep: str='') -> ndarray[_S]: ...
def identity(n: int, dtype: Type[_S]=None) -> ndarray[_S]: ...
def loadtxt(fname: Any, dtype: DtypeType=float, comments: Union[str, Sequence[str]]='#',
            delimiter: Optional[str]=None, converters: Optional[Dict[int, Callable[[Any], float]]]=None,
            skiprows: int=0, usecols: Optional[Sequence[int]]=None,
            unpack: bool=False, ndmin: int=0) -> ndarray[float]: ...
def ones(shape: ShapeType, dtype: Optional[DtypeType]=..., order: str='C') -> ndarray[Any]: ...
def ones_like(a: Any, dtype: Any=None, order: str='K', subok: bool=True) -> ndarray[Any]: ...
def reshape(array: ndarray[_S], newshape: ShapeType, order: str='C') -> ndarray[_S]: ...
def zeros(shape: ShapeType, dtype: Type[_S]=float, order: str='C') -> ndarray[_S]: ...
def zeros_like(a: Any, dtype: Any=None, order: str='K', subok: bool=True) -> ndarray[Any]: ...

def linspace(start: int,
             stop: int,
             num: int = 50,
             endpoint: bool = True,
             retstep: bool = False,
             dtype: Optional[dtype] = None,
             axis: int = 0) -> ArrayLike[Any]: ...
def meshgrid(*xi: ArrayLike[Any],
             copy: bool = True,
             sparse: bool = False,
             indexing: str = 'xy') -> ArrayLike[Any]: ...
def arange(start: Union[int, float] = ...,
           stop: Union[int, float] = ...,
           step: Union[int, float] = ...,
           dtype: Optional[dtype] = None,
           *,
           like: Optional[ndarray[Any]] = None) -> ArrayLike[Any]: ...
def dstack(tup: Union[List[Any], Tuple[ArrayLike[Any],...]]) -> ArrayLike[Any]: ...

# Specific values
inf: float